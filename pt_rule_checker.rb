# encoding: utf-8

#TODO:
# [] Design output support. markdown.
# []
# [] Known issues: Not catching all 'AND' rules.
# [] Non-Twitter rule analysis?


#### RuleChecker
# Attempts to assess the 'effectiveness' of PowerTrack rules.

# All configuration details are provided in a local config_private_internal.yaml file.
# For Gnip internal use there is an "internal" section of the config file:
#     Includes file path to CSV with accounts to check.
#     Includes credentials for reading customer rules.

#So, how do account passwords work?
#     Two versions of the password can be specified in config file:
#         account:password --> plain text if you must.
#         account:password_encoded --> #At least some resemblance of security. Generated by "base64" Ruby Gem.
#         [] TODO? build mechanism to encode/replace plain text passwords?

#Type of checks made:
# [x] Explicit AND rules.
# [ ] ORs and ANDs with no parentheses.
# [ ] ????

# Run modes:
# Gnip internal. Get rules via Rules API and "On-Behalf-Customer" header and system creds.
#      All Search API calls under internal Gnip account.
# Customer tool for own system: Rules API and Search calls under customer Gnip account.

#Gnip internal mode:
#   * Config file reads "systems to check" file and spins up multiple systems.
#   * Config file contains creds for Search API and
#   * Config file contains 'interval' hive for

#Customer tool:
#   * Config file spins up one system with one or more streams.
#   * Config file contains creds for Rules API and Search API.

#AND rule metadata:
#Rules with  "AND ": 55,042 (WORST OFFENDERS)
#Rules with  "AND ": 58,083
#Rules with  "AND " or " and " and no '"' (no double-quotes): 33,885






#-----------------------------------------------------------------------------------------------------------------------


require 'json'
require 'csv'
require 'logging'

require_relative './pt_restful'
require_relative './pt_rules'
require_relative './pt_logging'

#-----------------------------------------------------------------------------------------------------------------------
class PowerTrackSystem

  attr_accessor :account_name, :user_name,
                :password, :password_encoded,

                :streams, #Systems own one of more data streams.


                #Rule stats metadata.
                :activities_before, :activities_after,

                #App settings.
                :verbose,

                :logger

  def initialize
    @streams = [] #Array of stream objects.
    @verbose = false
  end

  def check(rules_api_creds, search_api_creds)

    logger.debug "Checking #{@account_name} streams..."

    @streams.each do |stream|
      stream.account_name = @account_name
      stream.check(rules_api_creds, search_api_creds)
    end

    write_system_output

    puts "Finished with  #{@account_name}..."
    puts '====================================================================='

  end

  #Write report text.
  def write_system_output

    puts "Writing #{@account_name} output..."

    @streams.each do |stream|
      stream.write_output
    end
  end
end

#-----------------------------------------------------------------------------------------------------------------------
class PowerTrackStream

  attr_accessor :account_name, :product, :publisher, :label,

                :http, :urlRules, :urlSearch,  #need a HTTP object to make requests of

                #Select Stream rule metadata.
                :rule_set, #PT Rules object, which owns an PTRule array.

                #TODO: Eliminate?
                :rules_AND, :rules_AND_corrected,
                :rule_count, :rule_AND_count,
                :rule_max, :rule_length_max, :rule_length_avg,

                #TODO: Push these down to Rule class?
                :rule_max_delta, :rule_max_delta_value, :rule_max_delta_30_day, :rule_max_delta_30_day_corrected,
                :rule_max_factor, :rule_max_factor_value, :rule_max_factor_30_day, :rule_max_factor_30_day_corrected,

                #App settings.
                :verbose,
                :request_sleep,

                :logger

  REGEX_AND = /(?<!["])(AND )(?!["])/
  COUNT_INTERVAL = 'day' #Search API count bucket size.

  def initialize
    @product = 'track' #Only product supported, only one needed.
    @publisher = 'twitter'
    @count_interval = 'day'

    @verbose = false
    @request_sleep = 0

    @rules = [] #Array of rule objects.
    @rules_AND = [] #Rules with explicit ANDs.
    @rules_AND_corrected = [] #Corrected version.

    @rule_length_max = 0
    @rule_length_avg = 0.0

    @http = PtRESTful.new
    @rule_set = PTRules.new
  end

  def call_rules_api rules_api_creds

    logger.debug "Retrieving rules for account: #{@account_name}..."

    @http.publisher = @publisher
    @http.url = @http.getRulesURL(@account_name, @label)
    @http.user_name = rules_api_creds['user_name']
    @http.password_encoded = rules_api_creds['password_encoded']

    headers = {}
    if rules_api_creds['user_name'] == 'system' then
      headers['X-ON-BEHALF-OF-ACCOUNT'] = @account_name
    end
    headers['Content-Type'] = 'application/json'
    headers['accept'] = 'application/json'

    response = @http.GET(nil,headers)
    #TODO: handle response.code > 299

    return response.body

  end


  def load_rules rules_api_creds

    response = call_rules_api rules_api_creds
    rules_json = JSON.parse(response)['rules']
    @rule_set.load_rules rules_json

  end

  def process_AND_rules




  end


  #Check the stream, do the rules analysis, etc.
  def check(rules_api_creds, search_api_creds)

    logger.debug  "Checking stream for #{@account_name}..."
    load_rules rules_api_creds

    rule_chars = 0
    rule_length = 0

    @rule_set.rules.each do |rule|
      puts rule.value

      #Rule stats
      rule_length = rule.value.length
      rule_chars = rule_chars + rule_length

      if rule_length > @rule_length_max then
        @rule_length_max = rule_length
        @rule_max = rule.value
      end

    end

    num_AND_rules = 0
    @rule_set.rules.each do |rule|

      if rule.is_a? PT_AND_RULE then
        num_AND_rules = num_AND_rules + 1
      end

    end

    #Stream rule attributes.
    @rule_count =@rule_set.rules.length
    @rule_length_avg = rule_chars/ @rule_count
    @rule_AND_count = num_AND_rules

    logger.debug "Analyzing AND rules..." if @rule_AND_count > 0
    logger.debug "Getting 30-day counts (before and after)..." if @rule_AND_count > 0

    ruleMetadata = []


    @rule_set.rules.each do |rule|


      #Call Search API counts for rule as originally written.
      counts_response = get_search_counts(search_api_creds, rule)

      if counts_response['results'].nil? or counts_response.include? 'error' or counts_response.include? 'Could not accept' then
        rule.value_corrected = ''
        if counts_response.include? 'Search does not currently support' then
          rule.value_corrected = "Rule has Operators unsupported by Search API."
        end

        rule.count_30_day = -1
        rule.count_30_day_corrected = nil
        rule.count_timeseries = -1
        rule.count_timeseries_corrected = nil

        logger.info "Skipping rule: #{rule}"
        next #skip
      end

      rule.count_30_day = get_count_total(counts_response)
      rule.count_timeseries = get_count_timeseries(counts_response)


      #Correct the rule.
      #regex = /(?<!["])(AND )(?!["])/
      rule.value_corrected = rule.value.gsub(REGEX_AND,"")
      oRule.value_corrected = value_corrected
      #puts rule_corrected

      #Call Search API counts for rule as originally written.
      counts_after = get_search_counts(search_api_creds, value_corrected)
    end


=begin THROW OUT


=end

    ruleMetadata = []

    #Special AND rule processing...
    rules_AND.each do |rule|

      oRule = PTRule.new
      oRule.rule = rule

      #Call Search API counts for rule as originally written.
      counts_before = get_search_counts(search_api_creds, rule)

      if counts_before['results'].nil? or counts_before.include? 'error' or counts_before.include? 'Could not accept' then
        if counts_before.include? 'Search does not currently support' then
         rule_corrected = "Rule has Operators unsupported by Search API."
        else
          rule_corrected = "Unknown error."
        end

        #logger.info "Skipping rule: #{rule}"

        oRule.count_30_day = -1
        oRule.count_30_day_corrected = -1
        oRule.count_timeseries = -1
        oRule.count_timeseries_corrected = -1

        next #skip
      end

      oRule.count_30_day = get_count_total(counts_before)
      oRule.count_timeseries = get_count_timeseries(counts_before)

      #Correct the rule.
      #regex = /(?<!["])(AND )(?!["])/
      rule_corrected = rule.gsub(REGEX_AND,"")
      oRule.rule_corrected = rule_corrected
      #puts rule_corrected

      #Call Search API counts for rule as originally written.
      counts_after = get_search_counts(search_api_creds, rule_corrected)

      if counts_after['results'].nil? or counts_after.include? 'error' or counts_after.include? 'Could not accept' then

        #logger.info "Skipping corrected rule: #{rule}"

        oRule.count_30_day = -1
        oRule.count_30_day_corrected = -1
        oRule.count_timeseries = -1
        oRule.count_timeseries_corrected = -1

        next #skip
      end

      oRule.count_30_day_corrected = get_count_total(counts_after)
      oRule.count_timeseries_corrected = get_count_timeseries(counts_after)
      if @verbose then
        puts
        puts rule
        puts "--> 30-day count --> Before: #{separate_comma(oRule.count_30_day)} | After: #{separate_comma(oRule.count_30_day_corrected)}"
        puts "                     Delta: #{separate_comma(oRule.count_30_day_corrected - oRule.count_30_day)} | Factor: #{'%.1f' % (oRule.count_30_day_corrected/(oRule.count_30_day * 1.0))}" if oRule.count_30_day > 0
      end

      ruleMetadata << oRule
    end

    #Calculate Stream-level things around the AND-correction results.
    rule_count_totals = 0.0
    rule_count_corrected_totals = 0.0
    delta = 0
    rule_max_delta  = 0.0
    rule_max_delta_30_day = 0
    rule_max_delta_30_day_corrected = 0
    rule_max_delta_value  = ''
    factor = 0
    rule_max_factor  = 0.0
    rule_max_factor_30_day = 0
    rule_max_factor_30_day_corrected = 0
    rule_max_factor_value  = ''

    ruleMetadata.each do |details|
      #Scan for biggest delta and biggest percentage change.
      rule_count_totals = rule_count_totals + details.count_30_day
      rule_count_corrected_totals = rule_count_corrected_totals + details.count_30_day_corrected

      delta = details.count_30_day_corrected - details.count_30_day
      if delta > rule_max_delta then
        rule_max_delta = delta
        rule_max_delta_30_day = details.count_30_day
        rule_max_delta_30_day_corrected = details.count_30_day_corrected
        rule_max_delta_value = details.rule
      end

      factor = (details.count_30_day_corrected/details.count_30_day.to_f) if details.count_30_day > 0
      if factor > rule_max_factor then
        rule_max_factor = factor
        rule_max_factor_30_day = details.count_30_day
        rule_max_factor_30_day_corrected = details.count_30_day_corrected
        rule_max_factor_value = details.rule
      end
    end

    #Harvest this stream's rule metadata.
    @rule_count_totals = rule_count_totals
    @rule_count_corrected_totals = rule_count_corrected_totals
    @rule_max_delta  = rule_max_delta
    @rule_max_delta_30_day = rule_max_delta_30_day
    @rule_max_delta_30_day_corrected = rule_max_delta_30_day_corrected
    @rule_max_delta_value  = rule_max_delta_value
    @rule_max_factor  = rule_max_factor
    @rule_max_factor_value  = rule_max_factor_value
    @rule_max_factor_30_day = rule_max_factor_30_day
    @rule_max_factor_30_day_corrected = rule_max_factor_30_day_corrected

  end

  def get_count_total(count_response)

    begin

      count_total = 0

      results = count_response["results"]
      results.each do |result|
        #p  result["count"]
        count_total = count_total + result["count"]
      end

      @count_total = count_total

    rescue
      logger.error 'ERROR calculating total count.'
    end
  end

  def get_count_timeseries(count_response)

    begin
      timeseries = []

      results = count_response["results"]
      results.each do |result|
        timeseries << result["count"]
      end

      timeseries
    rescue
      logger.error 'ERROR set count time-series.'
    end
  end

  def get_search_counts(search_api_creds, rule)

    @http.user_name = search_api_creds['user_name']
    @http.password_encoded = search_api_creds['password_encoded']
    @http.publisher = @publisher
    @http.url = @http.getSearchCountURL(search_api_creds['account_name'],search_api_creds['search_label'])

    #Build count request.
    search_request = {:publisher => @publisher, :query => rule, :bucket => COUNT_INTERVAL}
    data = JSON.generate(search_request)

    response = @http.POST(data)
    sleep @request_sleep

    if response.body.include? 'Rate limit exceeded' then
      sleep 5
      if @verbose then
        p "Rate limited, sleeping for 5 seconds before retrying..."
      end
      response = @http.POST(data) #retry
    end

    #p response.code

    begin
      response = JSON.parse(response.body)
    rescue
      logger.error "JSON parse error with: #{response.body}"
      response = '{"error"}'
    end

    return response
  end

  #Write Stream report text.
  def write_output(output_file=nil)

    return if output_file.nil?

    puts '=============================================================================================================='

    puts "Account/System name:#{@account_name}:"
    puts "Number of rules: #{separate_comma(@rule_count)}"
    puts "Rule average characters: #{separate_comma(@rule_length_avg)}"
    puts "Rule maximum characters: #{separate_comma(@rule_length_max)}"
    puts "Rule maximum value: #{@rule_max}"
    puts "Number of AND rules: #{separate_comma(@rule_AND_count)}"
    puts

    puts " #{@account_name} rule metadata --------------------------------------------------"
    puts "Longest rule has #{@rule_length_max} characters."
    puts "Average rule has #{@rule_length_avg} characters"

    puts "30-day counts before: #{separate_comma(@rule_count_totals.to_i)}" if @rule_AND_count > 0
    puts "30-day counts after: #{separate_comma(@rule_count_corrected_totals.to_i)}" if @rule_AND_count > 0
    puts "Rule with highest delta (#{@rule_max_delta} <= #{@rule_max_delta_30_day_corrected} - #{@rule_max_delta_30_day}): #{@rule_max_delta_value}" if @rule_AND_count > 0
    puts "Rule with highest factor (#{@rule_max_factor} <= #{@rule_max_factor_30_day_corrected} / #{@rule_max_factor_30_day}): #{@rule_max_factor_value}" if @rule_AND_count > 0
    puts
    puts "=============================================================================================================="
    puts


  end

  def separate_comma(number)
    number.to_s.chars.to_a.reverse.each_slice(3).map(&:join).join(",").reverse
  end

end


#-------------------------------------------------

class RulesApp

  require 'base64'

  attr_accessor :systems,
                :details_to_assign,
                :rules_api_creds,
                :search_api_creds,
                :streams_file, #Contains list of cross-account streams to check.
                :verbose,
                :logger

  def initialize
    #Class variables.
    @systems = []
    @details_to_assign = []
    @rules_api_creds = {}
    @search_api_creds = {}
    @verbose = false
  end

  #Load in the configuration file details, setting many object attributes.
  def get_app_config(config_file)

    logger.debug 'Loading configuration file.'

    #look locally, if not there then look in ./config folder/
    if !File.exist?(config_file) then
      config_file = "./config/#{config_file}"
    end

    config = {}
    config = YAML.load_file(config_file)

    #Config details.

    #Account details for Search API...
    #... and Rules API when used in 'customer' mode.
    account_name = config['account']['account_name']
    user_name = config['account']['user_name']

    #Users can pass in plain text, if they must.
    password_encoded = config["account"]["password_encoded"]
    if password_encoded.nil? then #User is passing in plain-text password...
        password = config["account"]["password"]
        password_encoded = Base64.encode64(@password)
    end

    search_label = config['account']['search_label']

    @search_api_creds['account_name'] = account_name
    @search_api_creds['user_name'] = user_name
    @search_api_creds['password_encoded'] = password_encoded
    @search_api_creds['search_label'] = search_label

    #App settings.
    begin
      @out_box = checkDirectory(config["app"]["out_box"])
    rescue
      @out_box = "./output"
    end

    #@log_file_path = config['app']['log_file_path']
    @verbose = config['app']['verbose']
    @request_sleep = config['app']['request_sleep']

    #Stream settings. Configured when used by customer. System/Account name is not included here because
    #we know the customer account from 'account' parameters.
    @details_to_assign = []
    if !config['streams'].nil? then
      config['streams'].each do |stream|
        details = {}
        details['publisher'] = stream['publisher']
        details['label'] = stream['label']
        @details_to_assign << details
      end
    end

    #Internal config details
    if !config["internal"].nil? then
      admin_user_name = config["internal"]["admin_user_name"]
      admin_password_encoded = config["internal"]["admin_password_encoded"]  #Plain text not suypported.
      #TODO: whitespace here breaks things... :(
      @streams_file = config["internal"]["streams_file"]
      #Running in 'internal' mode.
      #@rule_api_creds['account_name'] is dynamic, pulled from array of system objects.
      @rules_api_creds['user_name'] = admin_user_name
      @rules_api_creds['password_encoded'] = admin_password_encoded

      load_streams_from_file(@streams_file)
    else
      @rules_api_creds['account_name'] = account_name
      @rules_api_creds['user_name'] = user_name
      @rules_api_creds['password_encoded'] = password_encoded
    end
  end

  def load_streams_from_file(streams)

    @details_to_assign = []
    csv = CSV.read(streams, :headers => true)
    csv.each do |line|
      details = {}
      line_data = []
      line_data =  line.to_a
      details[line_data[0][0]] = (line_data[0][1]) #account_name
      details[line_data[1][0]] = (line_data[1][1]) #publisher
      details[line_data[2][0]] = (line_data[2][1]) #label

      if details["account_name"][0,1] != "#" then
        @details_to_assign << details
      end
    end
  end

  #App is driven by configured streams. This method discovers the associated systems and gets those set up.
  def load_systems_and_streams

    logger.debug 'Loading systems and streams.'

    if @rules_api_creds['user_name'] == 'system' then #Likely have multiple systems to load.

      system_names = []
      @details_to_assign.each do |details|

        new_stream = PowerTrackStream.new
        new_stream.publisher = details['publisher']
        new_stream.label = details['label']
        new_stream.verbose = @verbose
        new_stream.request_sleep = @request_sleep
        new_stream.logger = @logger


        if !system_names.include? details['account_name'] then
          system_names << details['account_name']

          #Creating a new host system.
          system = PowerTrackSystem.new
          system.account_name = details['account_name']
          system.verbose = @verbose
          system.logger = @logger

          @systems << system #Add system.
          system.streams << new_stream #Add stream to this system.

        else #The host system already exists, has a stream. So find it and add this one too.

          @systems.each do |system|
            if system.account_name == details['account_name'] then
              system.streams << new_stream
            end
          end
        end
      end
    else #Customer-mode -- have one system to load.
      system = PowerTrackSystem.new

      system.verbose = @verbose
      system.logger = @logger

      #Create this system's streams.
      @details_to_assign.each do |details|
        stream = PowerTrackStream.new
        stream.publisher = details['publisher']
        stream.label = details['label']
        stream.verbose = @verbose
        stream.request_sleep = @request_sleep
        stream.logger = @logger

        system.streams << stream
      end
    end
  end

  def check_systems
    @systems.each do |system|
      system.check @rules_api_creds, @search_api_creds
    end
  end

  def get_logger(config_file=nil)

    logging = PTLogging.new
    logging.get_config(config_file)
    @logger = logging.get_logger

  end

end
#-------------------------------------------------

#=======================================================================================================================
if __FILE__ == $0  #This script code is executed when running this file.

  #TODO: look for any '*config.yaml' file in app directory.
  config_file = './config/config_private_internal.yaml'

  oApp = RulesApp.new()

  oApp.get_logger(config_file)

  oApp.get_app_config(config_file) #This triggers loading of streams.

  oApp.load_systems_and_streams #Based on streams loaded.

  oApp.check_systems

end


