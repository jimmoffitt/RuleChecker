# encoding: utf-8

#TODO:
# [] Design output support. markdown.
# [] Provide Rules API ADD/DELETE request bodies.
# [x] Known issues: Not catching all 'AND' rules.
# [] Non-Twitter rule analysis?



#### RuleTranslator
# Attempts to assess the 'effectiveness' of PowerTrack rules.

# All configuration details are provided in a local config.yaml file.
# For Gnip internal use there is an "internal" section of the config file:
#     Includes file path to CSV with accounts to check.
#     Includes credentials for reading customer rules.

#So, how do account passwords work?
#     Two versions of the password can be specified in config file:
#         account:password --> plain text if you must.
#         account:password_encoded --> #At least some resemblance of security. Generated by "base64" Ruby Gem.
#         [] TODO? build mechanism to encode/replace plain text passwords?

#Type of checks made:
# [x] Explicit AND rules.
# [ ] ORs and ANDs with no parentheses.
#     "car OR truck ford OR general motors OR toyota" --> 14 M
#     "(car OR truck) (ford OR "general motors" OR toyota)" --> 190K
# [ ] ????

# Run modes:
# Gnip internal. Get rules via Rules API and "On-Behalf-Customer" header and system creds.
#      All Search API calls under internal Gnip account.
# Customer tool for own system: Rules API and Search calls under customer Gnip account.

#Gnip internal mode:
#   * Config file reads "systems to check" file and spins up multiple systems.
#   * Config file contains creds for Search API and
#   * Config file contains 'interval' hive for

#Customer tool:
#   * Config file spins up one system with one or more streams.
#   * Config file contains creds for Rules API and Search API.

#AND rule metadata:
#Rules with  "AND ": 55,042 (WORST OFFENDERS)
#Rules with  "AND ": 58,083
#Rules with  "AND " or " and " and no '"' (no double-quotes): 33,885

#-----------------------------------------------------------------------------------------------------------------------
require 'json'
require 'csv'
require 'logging'
require 'base64'

require_relative './pt_system'
require_relative './pt_stream'

require_relative './common/pt_restful'
require_relative './common/pt_rules'
require_relative './common/pt_logging'

#-----------------------------------------------------------------------------------------------------------------------
class PTRuleChecker

  attr_accessor :systems,
                :details_to_assign,
                :rules_api_creds,
                :search_api_creds,
                :streams_file, #Contains list of cross-account streams to check.
                :verbose,
                :logger

  def initialize
    #Class variables.
    @systems = []
    @details_to_assign = []
    @rules_api_creds = {}
    @search_api_creds = {}
    @verbose = false
  end

  #Load in the configuration file details, setting many object attributes.
  def get_app_config(config_file)

    logger.debug 'Loading configuration file.'

    #look locally, if not there then look in ./config folder/
    if !File.exist?(config_file) then
      config_file = "./config/#{config_file}"
    end

    config = {}
    config = YAML.load_file(config_file)

    #Config details.

    #Account details for Search API...
    #... and Rules API when used in 'customer' mode.
    account_name = config['account']['account_name']
    user_name = config['account']['user_name']

    #Users can pass in plain text, if they must.
    password_encoded = config["account"]["password_encoded"]
    if password_encoded.nil? then #User is passing in plain-text password...
        password = config["account"]["password"]
        password_encoded = Base64.encode64(@password)
    end

    search_label = config['account']['search_label']

    @search_api_creds['account_name'] = account_name
    @search_api_creds['user_name'] = user_name
    @search_api_creds['password_encoded'] = password_encoded
    @search_api_creds['search_label'] = search_label

    #App settings.
    begin
      @outbox = checkDirectory(config["app"]["outbox"])
    rescue
      @outbox = "./output"
    end

    #@log_file_path = config['app']['log_file_path']
    @verbose = config['app']['verbose']
    @request_sleep = config['app']['request_sleep']

    #Stream settings. Configured when used by customer. System/Account name is not included here because
    #we know the customer account from 'account' parameters.
    @details_to_assign = []
    if !config['streams'].nil? then
      config['streams'].each do |stream|
        details = {}
        details['publisher'] = stream['publisher']
        details['label'] = stream['label']
        @details_to_assign << details
      end
    end

    #Internal config details
    if !config["internal"].nil? then
      admin_user_name = config["internal"]["admin_user_name"]
      admin_password_encoded = config["internal"]["admin_password_encoded"]  #Plain text not suypported.
      #TODO: whitespace here breaks things... :(
      @streams_file = config["internal"]["streams_file"]
      #Running in 'internal' mode.
      #@rule_api_creds['account_name'] is dynamic, pulled from array of system objects.
      @rules_api_creds['user_name'] = admin_user_name
      @rules_api_creds['password_encoded'] = admin_password_encoded

      load_streams_from_file(@streams_file)
    else
      @rules_api_creds['account_name'] = account_name
      @rules_api_creds['user_name'] = user_name
      @rules_api_creds['password_encoded'] = password_encoded
    end
  end

  def load_streams_from_file(streams)

    @details_to_assign = []
    csv = CSV.read(streams, :headers => true)
    csv.each do |line|
      details = {}
      line_data = []
      line_data =  line.to_a
      details[line_data[0][0]] = (line_data[0][1]) #account_name
      details[line_data[1][0]] = (line_data[1][1]) #publisher
      details[line_data[2][0]] = (line_data[2][1]) #label

      if details["account_name"][0,1] != "#" then
        @details_to_assign << details
      end
    end
  end

  #App is driven by configured streams. This method discovers the associated systems and gets those set up.
  def load_systems_and_streams

    logger.debug 'Loading systems and streams.'

    if @rules_api_creds['user_name'] == 'system' then #Likely have multiple systems to load.

      system_names = []
      @details_to_assign.each do |details|

        new_stream = PTStream.new
        new_stream.publisher = details['publisher']
        new_stream.label = details['label']
        new_stream.request_sleep = @request_sleep
        #new_stream.logger = @logger


        if !system_names.include? details['account_name'] then
          system_names << details['account_name']

          #Creating a new host system.
          system = PTSystem.new
          system.account_name = details['account_name']
          system.verbose = @verbose
          system.outbox = @outbox
          system.logger = @logger

          @systems << system #Add system.
          system.streams << new_stream #Add stream to this system.

        else #The host system already exists, has a stream. So find it and add this one too.

          @systems.each do |system|
            if system.account_name == details['account_name'] then
              system.streams << new_stream
            end
          end
        end
      end
    else #Customer-mode -- have one system to load.
      system = PTSystem.new

      system.verbose = @verbose
      system.logger = @logger

      #Create this system's streams.
      @details_to_assign.each do |details|
        stream = PTStream.new
        stream.publisher = details['publisher']
        stream.label = details['label']
        #stream.verbose = @verbose
        stream.request_sleep = @request_sleep
        #stream.logger = @logger

        system.streams << stream
      end
    end
  end

  def check_systems
    @systems.each do |system|
      system.check_rules @rules_api_creds, @search_api_creds
    end
  end
  
  def make_rules_api_json
    @systems.each do |system|
      system.make_rules_api_json
    end
  end

  def get_logger(config_file=nil)

    logging = PTLogging.new
    logging.get_config(config_file)
    @logger = logging.get_logger
    logging.name = 'rule_checker'

  end

end
#-------------------------------------------------

#=======================================================================================================================
if __FILE__ == $0  #This script code is executed when running this file.

  #TODO: look for any '*config.yaml' file in app directory.
  config_file = './config/config_private_internal.yaml'

  oApp = PTRuleChecker.new()

  oApp.get_logger(config_file)

  oApp.get_app_config(config_file)

  oApp.load_systems_and_streams #Based on streams loaded.

  oApp.check_systems
  
  oApp.make_rules_api_json

end


